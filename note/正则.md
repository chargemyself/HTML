### 正则的作用
>正则:就是一个规则，用来处理字符串的一个规则（正则就是用来处理字符串的）
1. 匹配  判断一个字符串是否符合我们制定的规则->test　  reg.test(str)
```javascript
var reg = /\d/;
            console.log(reg.test('我'))//false
            console.log(reg.test('1'))//true
            console.log(reg.test('我102'))//true
```
2. 捕获  把字符串中符合我们正则规则的内容捕获到 exec  reg.exec(str)　
```javascript
var reg = /\d/;
            console.log(reg.exec('我'))//null
            console.log(reg.exec('1'))//["1",index:0,input:"1"]
```


### 如何创建一个正则
1. 字面量方式   var reg = /\d/
2. 实例创建方式  var reg =  new RegExp("");
正则两种创建方式是有区别的。  
> console.log(RegExp.prototype)  进行扩展

### 正则元字符和一些简单的应用。
1. 元字符：每一个正则表达式都是元字符和修饰符组成的。
> [元字符]-》在两个/之间具有意义的一些字符。  reg =/^\d$/ 一个0-9 之间的数字

```javascript
1. 具有特殊意义 的元字符
\: 转义字符，转义后面字符所代表的含义。
^: 以某一个元字符开始。
$： 以某一个元字符结尾。
\n :匹配一个换行符。
. ：除了\n 以外任意字符。
（） ：分组==》把一个大正则划分为几个小正则。
x|y ：x或者y里面种一个；
[xyz]: x或者y或者z中的一个。
[^xyz]: 除了三个以外的任何一个字符。
[a-z] : a-z之间任何一个字符；
[^a-z]: 除了a-z之间的任何一个字符。
\d :一个0-9 之间的字符；\D除了0-9之间的数字以外的任何字符。
\b : 一个边界符 "w1 w2 w3"
\w : 数字、字母、下划线中的任意一个字符 [0-9a-zA-Z_]
\s : 匹配一个空白字符  空格、一个制表符、换页符...
2. 代表出现次数的量词元字符
* ： 出现零次到多次
+ ： 出现1到多次
？ ：出现零次或者1次
{n} ：出现n次
{n,} :出现n到多次
{n,m} :出现n到m次　

```

```javascript
var reg = /^\d+wo\d+$/;// 123wo234
var reg = /^(\d+)wo(\d+)$/;
var reg = /^0.2$/   // 以0开头 2结尾，中间可以是除了\n的任意字符
var reg = /^\d+$/;//只能是多个数字
            console.log(reg.test('2017'))//true
            //一个简单的验证手机号的正则:11位数字，第一位为1
            var reg = /^1\d{10}$/;
```

2. 元字符的应用

```javascript
[]
1、在中括号中出现的所有的字符都是代表本身意思的字符（没有特殊的含义）。
2、中括号不识别两位数
var reg = /^[12-68]$/    ->代表1、2-6中的一个、8三个中的一个这个方法是错误的
()
1、分组的作用一: 改变x|y的默认的优先级　　
var reg = /^18|19$/;
//符合条件的有18、19、181、189、119、819、1819
var reg = /^(18|19)$/  //18、19
1、有效数字的正则   正数、负数、零、小数
　　　1）、"."可以出现也可以不出现，但是一旦出现，后面必须跟着一位或者多位数字
　　　2）、最开始可以有+/-也可以没有
　　　3）、整数部分，一位数可以是0-9之间的一个，多位数不能以0开头
　　　正则如下　　
var reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/
```

### 正则创建方式的区别及编写简单的正则
>在字面量方式中,我们//之间包起来的所有的内容都是元字符，有的具有特殊意义，大部分都是  代表本身含义的普通的元字符
```javascript
var name = 'wo';
var reg = /^\d+"+name+"\d+$/
为了解决上述想在正则里面加上一个变量这样的需求,我们只能使用实例创建的方式了
var reg = new RegExp("^\\d+"+name+"\\d+$","g")
字面量方式和实例创建的方式在正则中的区别?
1、字面量方式中出现的一切都是元字符,所以不能进行变量值的拼接，而实例创建的方式是可以的
2、字面量中直接写\d就可以，而在实例中需要把它转译\\d
```

```javascript
1、年龄介于18-65  // 年龄介于18-19  20-59   60-65
var  reg = /^(1[8-9] | [2-5]\d | 6[0-5])$/
2、验证邮箱的正则（简版）
邮箱左边的规律:数字、字母、下划线、.、-
var reg = /^[\w.-]+@[0-9a-zA-Z]+(\.[a-zA-Z]{2,4}){1,2}$/
3、中国标准真实姓名 2-4位汉字
var reg = /^[\u4e00-\u9fa5]{2,4}$/
4、身份证号码
var reg = /^\d{17}(\d | x)$/
var reg = /^\(d{2})(\d{4})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(\d | X)$/
```

### 正则懒惰型和贪婪性。
exec - > 正则的捕获  
每一次捕获的时候都是先进行默认的匹配，如果没有匹配成功的，捕获的结果是null；只有有匹配的内容我们才能捕获到；
捕获的内容格式
1、捕获到的内容是一个数组，数组中的第一项是当前正则捕获的内容

　　index:捕获内容在字符串中开始的索引位置

　　input:捕获的原始字符串

```javascript
var  reg = /\d+/;
var str = 'woshi2016ni2017';

var res = reg.exec(str);
console.log(res) // ['2016',index:5,input:'woshi2016ni2017']
//第二次通过exec捕获的内容还是第一个"2016"
var res = reg.exec(str);
console.log(res) // ['2016',index:5,input:'woshi2016ni2017']
```

`正则捕获的特点`

　　1）、懒惰性->每一次执行exec只捕获第一个匹配的内容，在不进行任何处理的情况下，在执行多次捕获，捕获的还是第一个匹配的内容。

　　lastIndex:是正则每一次捕获在字符串中开始查找的位置，默认值为0

　　2）、如何解决懒惰性?在正则的末尾加一个修饰符"g"

　　修饰符：g、i、m

　　global(g)：全局匹配

　　ignoreCase(i)：忽略大小写匹配

　　multiline(m):多行匹配　

```javascript
var reg = /\d/g;
var str = 'woshi2016ni2017';
console.log(reg.lastIndex)
console.log(reg.exec(str))
```
>原理:加了全局修饰符g，正则每一次捕获结束后，我们的lastIndex的值都变成了最新的值，   下一次捕获从最新的位置开始查找，这样就可以把所有需要捕获的内容都获取到了

　　3）、自己编写程序获取正则捕获的所有的内容(一定不要忘了加g)

```javascript
var reg = /\d+/g;
        var str = 'aswofde2015xsewde2016awdefer2017';
        var ary = [];
        var res = reg.exec(str);
        while(res){
            ary.push(res[0])
            res = reg.exec(str);
        }
        console.log(ary)//[2015,2016,2017]
```
4）、贪婪性   正则的每一次捕获都是按照匹配最长的结果捕获的，例如:2符合正则、2015也符合正则，我们默认捕获的是2015

5）、如何解决正则的贪婪性 ->在量词元字符后面添加一个？即可　
```javascript
var reg = /\d+?/g;
        var str = 'aswofde2015xsewde2016awdefer2017';
        console.log(reg.exec(str));
```
?在正则中有很多的作用:

放在一个普通的元字符后面代表出现0-1次 /\d?/  ->数字可能出现也可能不出现

放在一个量词的元字符后面是取消捕获时候的贪婪性

`字符串中的match方法->把所有和正则匹配的字符都获取到`
```javascript
var reg = /\d+?/g;
        var str = 'aswofde2015xsewde2016awdefer2017';
        var ary = str.match(reg);//[2,0,1,5,2,0,1,6,2,0,1,7]
```
虽然在当前的情况下match比我们的exec更加的简便一些，但是match中存在一些自己处理不了的问题，在分组的捕获的情况下，match只能捕获大正则匹配的内容，而对于小正则捕获的内容是无法获取的



```javascript

	// 元字符:
 //    *
 //    * .  表示的是:除了\n以外的任意的一个字符   "fdsfs238"
 //    *
 //    * [] 表示的是:范围,  [0-9] 表示的是0到9之间的任意的一个数字,  "789" [0-9]
 //    * [1-7] 表示的是1到7之间的任意的一个数字
 //    * [a-z] 表示的是:所有的小写的字母中的任意的一个
 //    * [A-Z] 表示的是:所有的大写的字母中的任意的一个
 //    * [a-zA-Z] 表示的是:所有的字母的任意的一个
 //    * [0-9a-zA-Z] 表示的是: 所有的数字或者是字母中的一个
 //    * [] 另一个函数: 把正则表达式中元字符的意义干掉    [.] 就是一个.
 //    * | 或者     [0-9]|[a-z] 表示的是要么是一个数字,要么是一个小写的字母
 //    * () 分组 提升优先级   [0-9]|([a-z])|[A-Z]
 //    * ([0-9])([1-5])([a-z]) 三组, 从最左边开始计算
 //    * (()(()))
 //    *
 //    *
 //    * 都是元字符,但是也可以叫限定符,下面的这些
 //    *    *   表示的是:前面的表达式出现了0次到多次
 //    *    [a-z][0-9]* 小写字母中的任意一个 后面是要么是没有数字的,要么是多个数字的
 //    *    "fdsfs3223323"  [a-z][0-9]*
 //    *
 //    *    +  表示的是:前面的表达式出现了1次到多次
 //    *    [a-z][9]+  小写字母一个后面最少一个9,或者多个9
 //    *    "fesfewww9fefds"
 //    *
 //    *    ?  表示的是:前面的表达式出现了0次到1次,最少是0次,最多1次 ,另一个含义:阻止贪婪模式
 //    *    [4][a-z]? "1231234ij"
 //    *  限定符:限定前面的表达式出现的次数
 //    *  {} 更加的明确前面的表达式出现的次数
 //    *  {0,} 表示的是前面的表达式出现了0次到多次,和 *一样的
 //    *  {1,} 表示的是前面的表达式出现了1次到多次,和 +一样的
 //    *  {0,1} 表示的是前面的表达式出现了0次到1次,和 ?一样的
 //    *  {5,10} 表示的是前面的表达式出现了5次到10次
 //    *  {4} 前面的表达式出现了4次
 //    *  {,10} 错误的========不能这么写
 //    *  ^ 表示的是以什么开始,或者是取非(取反) ^[0-9] 以数字开头
 //    *  ^[a-z] 以小写字母开始
 //    *  [^0-9] 取反,非数字
 //    *  [^a-z] 非小写字母
 //    *  [^0-9a-zA-Z_]
 //    *  $ 表示的是以什么结束   [0-9][a-z]$  必须以小写字母结束
 //    *  ^[0-9][a-z] 相当于是严格模式   "3f2432e"  "4f"
 //    *   \d 数字中的任意一个,
 //    *   \D 非数字中的一个
 //    *   \s 空白符中的一个
 //    *   \S 非空白符
 //    *   \w 非特殊符号
 //    *   \W 特殊符号
 //    *   \b 单词的边界
 //    *   "what are you no sha lei"

 //    *
 //    *    . 除了\n以外的任意一个单个字符
 //    *    []  范围
 //    *    () 分组,提升优先级
 //    *    | 或者
 //    *    * 0-多次
 //    *    + 1-多次
 //    *    ? 0-1次
 //    *    {0,} 和*一样
 //    *    {1,} 和+
 //    *    {0,1} 和?
 //    *
 //    *    \d 数字中的一个
 //    *    \D 非数字
 //    *    \s 空白符
 //    *    \S 非空白符
 //    *     \W  特殊符号
 //    *     \w 非特殊符号 _
 //    *     ^ 取反,以什么开始
 //    *     $ 以什么结束
 //         *
 //         *     \b 单词边界


// 写正则表达式根据字符串来写正则表达式
// 找规律，不要追求完美。
// 身份证的正则表达式
// 15位或者18位 ===
//   ([1-9][0-9]{14})|([1-9][0-9]{16}[0-9xX])

//   ===
//   ([1-9][0-9]{14})([0-9]{2}[0-9xX])?
//   第一位没有0，然后后面13位是0-9,15,16位是0-9.最后一位是0-9xX,最后三位要么出现一次，要么出现了0次

// 座机正则表达式
// 010-19876754
// 0431-87123499
//
// [0-9]{3,4}[-][0-9]{8};
// \d{3,4}[-]\d{8}
//
// 	QQ号码正则表达式
//
// 	[1-9][0-9]{4-10}
// 	\d{5-11}
//
// 	手机号码正则表达式
//
// 	130 131 132 133 134 135 135 137 138 139
// 	143 147
// 	150 151 152 153 154 155 156 157 158 159
// 	170 171 173 176 177
// 	180 181 182 183 184 185 186 187 188 189
// 	([1][358][0-9][0-9]{8})|([1][4][37][0-9]{8})|([1][7][01367][0-9]{8})
//
//
// 	邮箱的正则表达式
// 	[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}
//
// 中文名字的正则表达
// [\u4e00-\u9fa5]
// [\u4e00-\u9fa5_a-zA-Z0-9_]{4,10}   同时判断输入长度
// [a-zA-Z0-9_\u4e00-\u9fa5]+　　至少一个汉字、数字、字母、下划线

var str="我的helloworld，你的helloworld"
var newArr =str.match(/helloworld/g)
console.log(newArr);


var str1="2017-11-12";
var array =str1.match(/(\d{4})[-](\d{2})[-](\d{2})/g);

console.log(array);

console.log(RegExp.$3);

// 拿到邮箱的用户名字

var email ="814445238@qq.com"
var array1 = email.match(/([0-9a-zA-Z_.-]+)[@]([0-9a-zA-Z_-]+)(([.][a-zA-Z]+){1,2})/)
console.log(array1);
console.log(RegExp.$1)
console.log(RegExp.$2)
console.log(RegExp.$3)

var str="helloworld";
str =str.replace(/l/g,"x");
console.log(str);

var str ="HelllLLld";
str = str.replace(/l/ig,"x")
console.log(str);

```
